use proc_macro::TokenStream;
use proc_macro2::Span;
use quote::quote;
use syn::parse::{Parse, ParseStream};
use syn::{parse_macro_input, LitInt};

/// define_stack_payload!(128);
///
/// Expands to:
/// - `pub const STACK_PAYLOAD_SIZE: usize = 128;`
/// - `pub enum StandardSmallPayload { Inline1(SmallPayload<1>), ..., Inline128(...), Heap(Arc<[u8]>) }`
/// - impls with `new()`, `as_slice()`, `len()`, `to_arc()`, `is_inline()`, `Deref`, `Debug`.
struct Args {
    max: usize,
}

impl Parse for Args {
    fn parse(input: ParseStream<'_>) -> syn::Result<Self> {
        let max_lit: LitInt = input.parse()?;
        let max = max_lit.base10_parse::<usize>()?;
        Ok(Args { max })
    }
}

#[proc_macro]
pub fn define_stack_payload(input: TokenStream) -> TokenStream {
    let Args { max } = parse_macro_input!(input as Args);

    // Compute powers of two up to `max`
    let mut caps = Vec::new();
    let mut cap = 1usize;
    while cap <= max {
        caps.push(cap);
        cap *= 2;
    }

    // Variants like `Inline1(SmallPayload<1>), Inline2(...), ...`
    let variants = caps.iter().map(|c| {
        let vname = syn::Ident::new(&format!("Inline{}", c), Span::call_site());
        quote! {
            #vname(crate::small_payload::SmallPayload<#c>)
        }
    });

    // new() selection arms
    let new_arms = caps.iter().map(|c| {
        let vname = syn::Ident::new(&format!("Inline{}", c), Span::call_site());
        quote! {
            if len <= #c {
                return StandardSmallPayload::#vname(
                    crate::small_payload::SmallPayload::<#c>::new(data)
                );
            }
        }
    });

    // match arms for as_slice()
    let as_slice_arms = caps.iter().map(|c| {
        let vname = syn::Ident::new(&format!("Inline{}", c), Span::call_site());
        quote! {
            StandardSmallPayload::#vname(inner) => inner.as_slice(),
        }
    });

    // match arms for len()
    let len_arms = caps.iter().map(|c| {
        let vname = syn::Ident::new(&format!("Inline{}", c), Span::call_site());
        quote! {
            StandardSmallPayload::#vname(inner) => inner.len(),
        }
    });

    // match arms for len()
    let is_empty_arms = caps.iter().map(|c| {
        let vname = syn::Ident::new(&format!("Inline{}", c), Span::call_site());
        quote! {
            StandardSmallPayload::#vname(inner) => inner.is_empty(),
        }
    });

    // match arms for to_arc()
    let to_arc_arms = caps.iter().map(|c| {
        let vname = syn::Ident::new(&format!("Inline{}", c), Span::call_site());
        quote! {
            StandardSmallPayload::#vname(inner) => inner.to_arc(),
        }
    });

    // match arms for is_inline()
    let is_inline_arms = caps.iter().map(|c| {
        let vname = syn::Ident::new(&format!("Inline{}", c), Span::call_site());
        quote! {
            StandardSmallPayload::#vname(inner) => inner.is_inline(),
        }
    });

    // Debug arms
    let debug_arms = caps.iter().map(|c| {
        let vname = syn::Ident::new(&format!("Inline{}", c), Span::call_site());
        quote! {
            StandardSmallPayload::#vname(inner) => core::fmt::Debug::fmt(inner, f),
        }
    });

    // match arms for byte_cost()
    let byte_cost_arms = caps.iter().map(|c| {
        let vname = syn::Ident::new(&format!("Inline{}", c), Span::call_site());
        quote! {
            StandardSmallPayload::#vname(inner) => crate::queue::ByteCost::byte_cost(inner),
        }
    });

    let expanded = quote! {
            /// Max stack payload size generated by `define_stack_payload!`.
            pub const STACK_PAYLOAD_SIZE: usize = #max;

            #[derive(Clone)]
            pub enum StandardSmallPayload {
                #(#variants),*,
                Heap(alloc::sync::Arc<[u8]>),
            }

            impl StandardSmallPayload {
                #[inline]
                pub fn new(data: &[u8]) -> Self {
                    let len = data.len();
                    #(#new_arms)*
                    StandardSmallPayload::Heap(alloc::sync::Arc::from(data))
                }

                #[inline]
                pub fn as_slice(&self) -> &[u8] {
                    match self {
                        #(#as_slice_arms)*
                        StandardSmallPayload::Heap(arc) => arc,
                    }
                }

                #[inline]
                pub fn len(&self) -> usize {
                    match self {
                        #(#len_arms)*
                        StandardSmallPayload::Heap(arc) => arc.len(),
                    }
                }

                #[inline]
                pub fn is_empty(&self) -> bool {
                    match self {
                        #(#is_empty_arms)*
                        StandardSmallPayload::Heap(arc) => arc.is_empty(),
                    }
                }

                #[inline]
                pub fn to_arc(&self) -> alloc::sync::Arc<[u8]> {
                    match self {
                        #(#to_arc_arms)*
                        StandardSmallPayload::Heap(arc) => arc.clone(),
                    }
                }

                #[inline]
                pub fn is_inline(&self) -> bool {
                    match self {
                        #(#is_inline_arms)*
                        StandardSmallPayload::Heap(_) => false,
                    }
                }
            }


            impl crate::queue::ByteCost for StandardSmallPayload {
                #[inline]
                fn byte_cost(&self) -> usize {
                    match self {
                        #(#byte_cost_arms)*
                        // For heap payloads: approximate as payload length (+ optionally enum size)
                        StandardSmallPayload::Heap(arc) => {
                            core::mem::size_of::<StandardSmallPayload>() + arc.len()
                        }
                    }
                }
            }

            impl core::cmp::PartialEq for StandardSmallPayload {
                #[inline]
                fn eq(&self, other: &Self) -> bool {
                    self.as_slice() == other.as_slice()
                }
            }
            impl core::cmp::Eq for StandardSmallPayload {}

            impl core::cmp::PartialEq<[u8]> for StandardSmallPayload {
                #[inline]
                fn eq(&self, other: &[u8]) -> bool {
                    self.as_slice() == other
                }
            }

            impl core::cmp::PartialEq<StandardSmallPayload> for [u8] {
                #[inline]
                fn eq(&self, other: &StandardSmallPayload) -> bool {
                    self == other.as_slice()
                }
            }

            impl core::cmp::PartialEq<alloc::sync::Arc<[u8]>> for StandardSmallPayload {
                #[inline]
                fn eq(&self, other: &alloc::sync::Arc<[u8]>) -> bool {
                    self.as_slice() == other.as_ref()
                }
            }

            impl core::ops::Deref for StandardSmallPayload {
                type Target = [u8];
                #[inline]
                fn deref(&self) -> &[u8] {
                    self.as_slice()
                }
            }

            impl core::fmt::Debug for StandardSmallPayload {
                #[inline]
                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                    match self {
                        #(#debug_arms)*
                        StandardSmallPayload::Heap(arc) => write!(
                            f,
                            "{}::Heap({} bytes)",
                            stringify!(StandardSmallPayload),
                            arc.len()
                        ),
                    }
                }
            }
        };

    expanded.into()
}
