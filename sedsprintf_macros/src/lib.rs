use proc_macro::TokenStream;
use proc_macro2::Span;
use quote::quote;
use syn::parse::{Parse, ParseStream};
use syn::{parse_macro_input, Ident, LitInt, LitStr, Token};

/// define_stack_payload!(env = "max_stack_payload", default = 8);
///
/// Reads the *build-time* environment variable `max_stack_payload` while the proc-macro runs.
/// - If missing or invalid, falls back to `default`.
///
/// Expands to:
/// - `pub const STACK_PAYLOAD_SIZE: usize = <resolved>;`
/// - `pub enum StandardSmallPayload { Inline1(SmallPayload<1>), ..., InlineN(...), Heap(Arc<[u8]>) }`
/// - impls with `new()`, `as_slice()`, `len()`, `to_arc()`, `is_inline()`, `Deref`, `Debug`.
struct Args {
    env_name: String,
    default: usize,
}

impl Parse for Args {
    fn parse(input: ParseStream<'_>) -> syn::Result<Self> {
        // env = "..."
        let k1: Ident = input.parse()?;
        if k1 != "env" {
            return Err(syn::Error::new_spanned(k1, "expected `env`"));
        }
        input.parse::<Token![=]>()?;
        let env_lit: LitStr = input.parse()?;

        input.parse::<Token![,]>()?;

        // default = 8
        let k2: Ident = input.parse()?;
        if k2 != "default" {
            return Err(syn::Error::new_spanned(k2, "expected `default`"));
        }
        input.parse::<Token![=]>()?;
        let default_lit: LitInt = input.parse()?;
        let default = default_lit.base10_parse::<usize>()?;

        Ok(Self {
            env_name: env_lit.value(),
            default,
        })
    }
}

fn read_max_from_env(env_key: &str, default: usize) -> usize {
    match std::env::var(env_key) {
        Ok(v) => match v.trim().parse::<usize>() {
            Ok(n) if n > 0 => n,
            _ => default, // invalid -> default
        },
        Err(_) => default, // missing -> default
    }
}

#[proc_macro]
pub fn define_stack_payload(input: TokenStream) -> TokenStream {
    let Args { env_name, default } = parse_macro_input!(input as Args);

    let max = read_max_from_env(&env_name, default);

    // Compute powers of two up to `max`
    let mut caps = Vec::new();
    let mut cap = 1usize;
    while cap <= max {
        caps.push(cap);
        cap *= 2;
    }

    // Variants like `Inline1(SmallPayload<1>), Inline2(...), ...`
    let variants = caps.iter().map(|c| {
        let vname = syn::Ident::new(&format!("Inline{}", c), Span::call_site());
        quote! {
            #vname(crate::small_payload::SmallPayload<#c>)
        }
    });

    // new() selection arms
    let new_arms = caps.iter().map(|c| {
        let vname = syn::Ident::new(&format!("Inline{}", c), Span::call_site());
        quote! {
            if len <= #c {
                return StandardSmallPayload::#vname(
                    crate::small_payload::SmallPayload::<#c>::new(data)
                );
            }
        }
    });

    // match arms for as_slice()
    let as_slice_arms = caps.iter().map(|c| {
        let vname = syn::Ident::new(&format!("Inline{}", c), Span::call_site());
        quote! {
            StandardSmallPayload::#vname(inner) => inner.as_slice(),
        }
    });

    // match arms for len()
    let len_arms = caps.iter().map(|c| {
        let vname = syn::Ident::new(&format!("Inline{}", c), Span::call_site());
        quote! {
            StandardSmallPayload::#vname(inner) => inner.len(),
        }
    });

    // match arms for is_empty()
    let is_empty_arms = caps.iter().map(|c| {
        let vname = syn::Ident::new(&format!("Inline{}", c), Span::call_site());
        quote! {
            StandardSmallPayload::#vname(inner) => inner.is_empty(),
        }
    });

    // match arms for to_arc()
    let to_arc_arms = caps.iter().map(|c| {
        let vname = syn::Ident::new(&format!("Inline{}", c), Span::call_site());
        quote! {
            StandardSmallPayload::#vname(inner) => inner.to_arc(),
        }
    });

    // match arms for is_inline()
    let is_inline_arms = caps.iter().map(|c| {
        let vname = syn::Ident::new(&format!("Inline{}", c), Span::call_site());
        quote! {
            StandardSmallPayload::#vname(inner) => inner.is_inline(),
        }
    });

    // Debug arms
    let debug_arms = caps.iter().map(|c| {
        let vname = syn::Ident::new(&format!("Inline{}", c), Span::call_site());
        quote! {
            StandardSmallPayload::#vname(inner) => core::fmt::Debug::fmt(inner, f),
        }
    });

    // match arms for byte_cost()
    let byte_cost_arms = caps.iter().map(|c| {
        let vname = syn::Ident::new(&format!("Inline{}", c), Span::call_site());
        quote! {
            StandardSmallPayload::#vname(inner) => crate::queue::ByteCost::byte_cost(inner),
        }
    });

    let expanded = quote! {
        /// Max stack payload size generated by `define_stack_payload!`.
        ///
        /// This value is resolved at compile time by the proc-macro by reading
        /// the build environment variable specified in the macro invocation.
        pub const STACK_PAYLOAD_SIZE: usize = #max;

        #[derive(Clone)]
        pub enum StandardSmallPayload {
            #(#variants),*,
            Heap(alloc::sync::Arc<[u8]>),
        }

        impl StandardSmallPayload {
            #[inline]
            pub fn new(data: &[u8]) -> Self {
                let len = data.len();
                #(#new_arms)*
                StandardSmallPayload::Heap(alloc::sync::Arc::from(data))
            }

            #[inline]
            pub fn as_slice(&self) -> &[u8] {
                match self {
                    #(#as_slice_arms)*
                    StandardSmallPayload::Heap(arc) => arc,
                }
            }

            #[inline]
            pub fn len(&self) -> usize {
                match self {
                    #(#len_arms)*
                    StandardSmallPayload::Heap(arc) => arc.len(),
                }
            }

            #[inline]
            pub fn is_empty(&self) -> bool {
                match self {
                    #(#is_empty_arms)*
                    StandardSmallPayload::Heap(arc) => arc.is_empty(),
                }
            }

            #[inline]
            pub fn to_arc(&self) -> alloc::sync::Arc<[u8]> {
                match self {
                    #(#to_arc_arms)*
                    StandardSmallPayload::Heap(arc) => arc.clone(),
                }
            }

            #[inline]
            pub fn is_inline(&self) -> bool {
                match self {
                    #(#is_inline_arms)*
                    StandardSmallPayload::Heap(_) => false,
                }
            }
        }

        impl crate::queue::ByteCost for StandardSmallPayload {
            #[inline]
            fn byte_cost(&self) -> usize {
                match self {
                    #(#byte_cost_arms)*
                    StandardSmallPayload::Heap(arc) => {
                        core::mem::size_of::<StandardSmallPayload>() + arc.len()
                    }
                }
            }
        }

        impl core::cmp::PartialEq for StandardSmallPayload {
            #[inline]
            fn eq(&self, other: &Self) -> bool {
                self.as_slice() == other.as_slice()
            }
        }
        impl core::cmp::Eq for StandardSmallPayload {}

        impl core::cmp::PartialEq<[u8]> for StandardSmallPayload {
            #[inline]
            fn eq(&self, other: &[u8]) -> bool {
                self.as_slice() == other
            }
        }

        impl core::cmp::PartialEq<StandardSmallPayload> for [u8] {
            #[inline]
            fn eq(&self, other: &StandardSmallPayload) -> bool {
                self == other.as_slice()
            }
        }

        impl core::cmp::PartialEq<alloc::sync::Arc<[u8]>> for StandardSmallPayload {
            #[inline]
            fn eq(&self, other: &alloc::sync::Arc<[u8]>) -> bool {
                self.as_slice() == other.as_ref()
            }
        }

        impl core::ops::Deref for StandardSmallPayload {
            type Target = [u8];
            #[inline]
            fn deref(&self) -> &[u8] {
                self.as_slice()
            }
        }

        impl core::fmt::Debug for StandardSmallPayload {
            #[inline]
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                match self {
                    #(#debug_arms)*
                    StandardSmallPayload::Heap(arc) => write!(
                        f,
                        "{}::Heap({} bytes)",
                        stringify!(StandardSmallPayload),
                        arc.len()
                    ),
                }
            }
        }
    };

    expanded.into()
}
