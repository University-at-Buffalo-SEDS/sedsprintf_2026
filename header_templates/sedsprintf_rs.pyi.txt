# sedsprintf_rs.pyi
# =============================
# Auto-generated Python type stubs for sedsprintf_rs. DO NOT EDIT AS CHANGES WILL BE OVERWRITTEN.
# =============================
from __future__ import annotations

from typing import Any, Callable, Optional, Sequence, Tuple, List, Dict, Literal, Union
from enum import IntEnum
from collections.abc import Buffer  # Python 3.12 buffer protocol typing


# ==============================
# Public enums / constants (parity with C header)
# ==============================

from enum import IntEnum

/* {{AUTOGEN:PY_ENUMS}} */

class ElemKind(IntEnum):
    """Element kind for generic logging (C API parity)."""
    UNSIGNED: int  #: Unsigned integers (u8/u16/u32/u64).
    SIGNED: int    #: Signed integers (i8/i16/i32/i64).
    FLOAT: int     #: Floating-point (f32/f64).


class RouterMode(IntEnum):
    Relay: int
    Sink: int


# ==============================
# Callback protocols (informal)
# ==============================

TxCallback = Union[
    Callable[[bytes], None],
    Callable[[bytes, LinkId], None],
]
"""Transmit callback. May be called as tx(bytes) or tx(bytes, link_id)."""

NowMsCallback = Callable[[], int]
"""Clock callback returning monotonic milliseconds."""

PacketHandler = Union[
    Callable[["Packet"], None],
    Callable[["Packet", LinkId], None],
]
"""Endpoint handler invoked with (Packet) or (Packet, link_id)."""

SerializedHandler = Union[
    Callable[[bytes], None],
    Callable[[bytes, LinkId], None],
]
"""Endpoint handler invoked with (bytes) or (bytes, link_id)."""

SideId = int
"""Logical relay side index (e.g. CAN, UART, RADIO)."""

# ==============================
# Packet object (immutable view of a telemetry packet)
# ==============================

class Packet:
    """
    Immutable, heap-backed telemetry packet.

    Attributes:
        ty:           DataType as an int (use DataType(...) to coerce).
        data_size:    Declared schema payload size (bytes).
        sender:       Sender string from the packet header.
        endpoints:    List of DataEndpoint values as ints.
        timestamp_ms: Packet timestamp in milliseconds (u64).
        payload:      Raw payload bytes (already validated for size/schema).
    """

    @property
    def ty(self) -> int: ...
    @property
    def data_size(self) -> int: ...
    @property
    def sender(self) -> str: ...
    @property
    def endpoints(self) -> List[int]: ...
    @property
    def timestamp_ms(self) -> int: ...
    @property
    def payload(self) -> bytes: ...

    def header_string(self) -> str: ...
    def __str__(self) -> str: ...
    def wire_size(self) -> int: ...
    def serialize(self) -> bytes: ...

    # Typed payload decoders (mirror TelemetryPacket::data_as_*)
    def data_as_u8(self) -> List[int]: ...
    def data_as_u16(self) -> List[int]: ...
    def data_as_u32(self) -> List[int]: ...
    def data_as_u64(self) -> List[int]: ...

    def data_as_i8(self) -> List[int]: ...
    def data_as_i16(self) -> List[int]: ...
    def data_as_i32(self) -> List[int]: ...
    def data_as_i64(self) -> List[int]: ...

    def data_as_f32(self) -> List[float]: ...
    def data_as_f64(self) -> List[float]: ...

    def data_as_bool(self) -> List[bool]: ...
    def data_as_string(self) -> str: ...

# ==============================
# Router (lifecycle, logging, queues)
# ==============================

class Router:
    @staticmethod
    def new_singleton(
        tx: Optional[TxCallback] = ...,
        now_ms: Optional[NowMsCallback] = ...,
        handlers: Optional[
            Sequence[Tuple[int, Optional[PacketHandler], Optional[SerializedHandler]]]
        ] = ...,
        mode: Union[RouterMode, int] = ...,
    ) -> "Router": ...
    """
        Create or retrieve a per-process singleton Router.

        The first call creates the singleton with the given `tx` callback
        (no clock and no endpoint handlers). Subsequent calls return another
        Router object wrapping the same underlying singleton instance.

        Passing a non-None `tx` after the singleton has already been created
        will raise a RuntimeError.
        """

    def __init__(
        self,
        tx: Optional[TxCallback] = ...,
        now_ms: Optional[NowMsCallback] = ...,
        handlers: Optional[
            Sequence[Tuple[int, Optional[PacketHandler], Optional[SerializedHandler]]]
        ] = ...,
        mode: Union[RouterMode, int] = ...,
    ) -> None: ...

    def log_bytes(
        self,
        ty: int,
        data: Buffer | bytes | bytearray | memoryview,
        timestamp_ms: Optional[int] = ...,
        queue: bool = ...,
    ) -> None: ...

    def log_f32(
        self,
        ty: int,
        values: Sequence[float] | Buffer | bytes | bytearray | memoryview,
        timestamp_ms: Optional[int] = ...,
        queue: bool = ...,
    ) -> None: ...

    def log(
        self,
        ty: int,
        data: Buffer | bytes | bytearray | memoryview | str,
        elem_size: Literal[1, 2, 4, 8],
        elem_kind: Literal[ElemKind.UNSIGNED, ElemKind.SIGNED, ElemKind.FLOAT, 0, 1, 2],
        timestamp_ms: Optional[int] = ...,
        queue: bool = ...,
    ) -> None: ...

    # Legacy/default-link methods (still supported)
    def transmit_message_queue(self, packet: Packet) -> None: ...
    def transmit_message(self, packet: Packet) -> None: ...
    def transmit_serialized_message(self, data: Buffer | bytes | bytearray | memoryview) -> None: ...
    def transmit_serialized_message_queue(self, data: Buffer | bytes | bytearray | memoryview) -> None: ...
    def receive_serialized(self, data: Buffer | bytes | bytearray | memoryview) -> None: ...

    # NEW: link-aware methods
    def transmit_message_from(self, link_id: LinkId, packet: Packet) -> None: ...
    def transmit_message_queue_from(self, link_id: LinkId, packet: Packet) -> None: ...
    def transmit_serialized_message_from(self, link_id: LinkId, data: Buffer | bytes | bytearray | memoryview) -> None: ...
    def transmit_serialized_message_queue_from(self, link_id: LinkId, data: Buffer | bytes | bytearray | memoryview) -> None: ...

    def receive_serialized_from(self, link_id: LinkId, data: Buffer | bytes | bytearray | memoryview) -> None: ...
    def receive_serialized_queue(self, data: Buffer | bytes | bytearray | memoryview) -> None: ...
    def receive_serialized_queue_from(self, link_id: LinkId, data: Buffer | bytes | bytearray | memoryview) -> None: ...

    # Queue processing
    def process_send_queue(self) -> None: ...
    def process_received_queue(self) -> None: ...
    def process_all_queues(self) -> None: ...
    def clear_rx_queue(self) -> None: ...
    def clear_tx_queue(self) -> None: ...
    def clear_queues(self) -> None: ...

    def process_tx_queue_with_timeout(self, timeout_ms: int) -> None: ...
    def process_rx_queue_with_timeout(self, timeout_ms: int) -> None: ...
    def process_all_queues_with_timeout(self, timeout_ms: int) -> None: ...

# ==============================
# Relay (fan-out of serialized packets)
# ==============================

class Relay:
    """
    Serialized-packet relay.

    The Relay:
        - fans out serialized telemetry packets from one side to all others
        - has RX and TX queues (same pattern as Router)
        - supports time-budgeted queue processing
        - uses the same monotonic clock callback style as Router
    """
    def __init__(self, now_ms: Optional[NowMsCallback] = ...) -> None: ...
    """
        Create a new Relay.

        Parameters
        ----------
        now_ms:
            Optional zero-arg callback returning an integer timestamp in ms.
            If None, timeouts are based on a default clock that returns 0.
        """

    def add_side_serialized(self, name: str, tx: Callable[[bytes], None]) -> SideId: ...
    """
        Add a new relay side (e.g. 'CAN', 'UART', 'RADIO').

        Parameters
        ----------
        name:
            Human-readable name for this side (used for debugging).
        tx:
            Transmit callback. Called as ``tx(bytes)`` when the relay
            wants to send data on this side.

        Returns
        -------
        SideId
            Integer side id to use with ``rx_serialized_from_side``.
        """
    def add_side_packet(self, name: str, tx: Callable[[Packet], None]) -> SideId: ...
    """
        Add a new side with a packet-based TX callback.

        Parameters
        ----------
        name:
            Human-readable name for this side (used for debugging).
        tx:
            Transmit callback. Called as ``tx(pkt: Packet)`` when the relay
            wants to send a TelemetryPacket on this side.

        Returns
        -------
        SideId
            Integer side id to use with ``rx_serialized_from_side`` and ``rx_from_side``.
        """

    def rx_packet_from_side(self, side_id: SideId, packet: Packet) -> None: ...
    """
        Enqueue a full Packet that arrived on a given side into the relay RX queue.

        Parameters
        ----------
        side_id:
            Side id previously returned by :meth:`add_side` or :meth:`add_side_packet`.
        packet:
            A :class:`Packet` instance.
        """
    def rx_serialized_from_side(self, side_id: SideId, data: Buffer | bytes | bytearray | memoryview) -> None: ...
    """
        Enqueue serialized bytes that arrived on a given side into the relay RX queue.

        Parameters
        ----------
        side_id:
            Side id previously returned by :meth:`add_side`.
        data:
            Serialized packet bytes.
        """
    def clear_queues(self) -> None: ...
    def clear_rx_queue(self) -> None: ...
    def clear_tx_queue(self) -> None: ...

    def process_rx_queue(self) -> None: ...
    def process_tx_queue(self) -> None: ...
    def process_all_queues(self) -> None: ...

    def process_rx_queue_with_timeout(self, timeout_ms: int) -> None: ...
    def process_tx_queue_with_timeout(self, timeout_ms: int) -> None: ...
    def process_all_queues_with_timeout(self, timeout_ms: int) -> None: ...

# ==============================
# Top-level helpers
# ==============================

def deserialize_packet_py(data: Buffer | bytes | bytearray | memoryview) -> Packet: ...
def peek_header_py(data: Buffer | bytes | bytearray | memoryview) -> Dict[str, Any]: ...
def make_packet(
    ty: int,
    sender: str,
    endpoints: Sequence[int],
    timestamp_ms: int,
    payload: Buffer | bytes | bytearray | memoryview,
) -> Packet: ...
